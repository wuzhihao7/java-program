# 令牌桶算法

令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。 当桶满时，新添加的令牌被丢弃或拒绝。

**在Google Guava 中提供了一个 RateLimiter 工具类，就是基于令牌桶算法实现平滑突发的限流策略，令牌桶的好处是可以方便的改变速度. 一旦需要提高速率,则按需提高放入桶中的令牌的速率. 一般会定时(比如1000毫秒)往桶中增加一定数量的令牌, 有些变种算法则可以实时的计算应该增加的令牌的数量**

![ä»¤çæ¡¶ç®æ³](https://image.battcn.com/article/images/20180724/service/limiting-strategy/1.png)

# 漏桶算法

**其主要目的是控制数据注入到网络的速率，平滑网络上的突发流量，数据可以以任意速度流入到漏桶中。** 漏桶算法提供了一种机制，通过它，突发流量可以被整形以便为网络提供一个稳定的流量。 漏桶可以看作是一个带有常量服务时间的单服务器队列，如果漏桶为空，则不需要流出水滴，如果漏桶（包缓存）溢出，那么水滴会被溢出丢弃。

![æ¼æ¡¶ç®æ³](https://image.battcn.com/article/images/20180724/service/limiting-strategy/2.png)

漏铜算法可以通过 `信号量（Semaphore）` 的方式实现，很好的达到消峰的目的，如果队列中任务存活个数就如同是水桶最多能盛装的水量，当超出这个阀值就会丢弃任务….

**Semaphore** 是 JDK1.5 提供用于限制获取某种资源的线程数量，拥有有 **公平、非公平** 两种模式。**公平则是顺序获取信号，遵循（FIFO）先进先出，而非公平模式则是凭本事抢资源，想先进先出？不存在的。默认是非公平的**

# 计数器限流

计数器限流算法是比较常用一种的限流方案也是最为粗暴直接的，主要用来限制总并发数，比如数据库连接池大小、线程池大小、接口访问并发数等都是使用计数器算法…

使用 **AomicInteger** 来进行统计当前正在并发执行的次数，如果超过域值就直接拒绝请求，提示系统繁忙

**AtomicInteger** 是 JDK1.5 提供的拥有原子特性的计数功能，都知道在多线程环境下 num++ 是非原子的，但是有了 `AtomicInteger` 后这个问题可以非常简单的解决，它就像是 `redis incr`