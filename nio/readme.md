# 概念

## 同步与异步

> **同步**

如果有多个任务或者时间发生，这些任务或事件必须逐个地执行，一个事件或者任务的执行会导致整个流程的暂时等待，这些事件没有办法并发的执行。

> **异步**

如果有多个任务或者事件发生，这些任务或事件可以并发地执行，一个事件或者任务的执行不会导致整个流程的暂时等待。

## 阻塞与非阻塞

> **阻塞**

当某个任务或者事件在执行过程中，它发出一个请求操作，但是由于该请求操作需要的条件不满足，那么就会一直在那等待，直至条件满足。

> 非阻塞

当某个任务或者事件在执行过程中，它发出一个请求操作，如果该请求操作需要的条件不满足，会立即返回一个标识信息告知条件不满足，不会一直在那等待。

***同步和异步着重点在于多个任务的执行过程中，一个任务的执行是否会导致整个流程的暂时等待；***

***阻塞和非阻塞着重点在于发出一个请求操作时，如果进行操作的条件不满足是否会返会一个标志信息告知条件不满足。***

## 阻塞IO与非阻塞IO

通常来说，IO操作包括：对硬盘的读写，对socket的读写以及外设的读写。

当用户线程发起一个IO请求操作（已读请求操作为例），内核会去查看要读取的数据是否就绪，对于阻塞IO来说，如果数据没有就绪，则会一直在那等待，知道数据就绪；对于非阻塞IO来说，如果数据没有就绪，则会返回一个标识信息告知用户线程当前要读的数据没有就绪。当数据就绪之后，便将数据拷贝到用户线程，这样才完成了一个完整的IO读请求操作，也就是说一个完整的IO读请求操作包括两个阶段：

- 查看数据是否就绪
- 进行数据拷贝（内核将数据拷贝到用户线程）

那么阻塞IO和非阻塞IO的区别就在于第一个阶段，如果数据没有就绪，就查看数据是否就绪的过程中是一直等待，还是直接返回一个标识信息。

java中传统的IO都是阻塞IO，比如通过socket来读数据，调用read()方法后，如果数据没有就绪，当前线程会一直阻塞在read()方法调用那里，直到有数据才返回；而如果是非阻塞IO的话，当数据没有就绪，read()方法应该返回一个标识信息，告知当前线程数据没有就绪，而不是一直在那里等待。

## 同步IO与异步O

同步IO和异步IO模型是针对用户线程和内核的交互来说的

> **同步IO**

如果一个线程请求进行IO操作，在IO操作完成之前，该线程会被阻塞。

当用户发出IO请求操作之后，如果数据没有就绪，需要通过用户线程或者内核不断地去轮询数据是否就绪，当数据就绪时，再将数据拷贝到用户线程。

> **异步IO**

如果一个线程请求进行IO操作，IO操作不会导致请求线程被阻塞。

只有IO请求操作的发出是由用户线程来进行的，IO操作的两个阶段都是由内核自动完成，然后发送通知告知用户线程IO操作已经完成。

***同步IO和异步IO的关键区别反映在数据拷贝阶段是由用户线程完成还是内核完成。所以异步IO必须要有操作系统的底层支持。***

***阻塞IO和非阻塞IO是反映在当用户请求IO操作时，如果数据没有就绪，是用户线程一直等待数据就绪，还是会收到一个标识信息这一点上面的。也就是说，阻塞IO和非阻塞IO是反映在IO操作的第一个阶段，在查看数据是否就绪时是如何处理的。***

# 五种IO模型

