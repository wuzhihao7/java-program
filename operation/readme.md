# 位运算
> 符号位

二进制数最高位表示符号位，0表示正数，1表示负数。

> 原码

正数的二进制数

> 反码

符号位不变，其余部分取反

> 补码

原码取反加1，符号位不变。或者说反码1，符号为不变。

负数的补码即为：正数的原码取反，再加1，即正数的补码就是负数的原码。

> 位运算符

| 含义                         | 运算符 | 例子               |
| ---------------------------- | ------ | ------------------ |
| 左移                         | <<     | 0011 => 0110       |
| 右移                         | >>     | 0110 => 0011       |
| 按位或                       | \|     | 0011\|1001 => 1011 |
| 按位与                       | &      | 0011&1011 => 0011  |
| 按位取反                     | ~      | ~0011 => 1100      |
| 按位异或(相同为零，不同为一) | ^      | 0011^1011 => 1000  |



# 加法和乘法

> 加法

计算两个数的和，因为在计算机中都是以二进制来进行运算，所以上面我们所给的int变量会在机器内部先转换为二进制在进行相加

```java
int a = 35;
int b = 47;
int c = a + b;

35:  0 0 1 0 0 0 1 1
47:  0 0 1 0 1 1 1 1
————————————————————
82:  0 1 0 1 0 0 1 0

```

> 乘法

```java
int a = 3;
int b = 2;
int c = a * b;

3:  0 0 0 0 0 0 1 1  *  2
————————————————————
6:  0 0 0 0 0 1 1 0

*********************************************

int a = 3;
int b = 4;
int c = a * b;

3:  0 0 0 0 0 0 1 1  *  4
————————————————————
12:  0 0 0 0 1 1 0 0

*********************************************

int a = 3;
int b = 8;
int c = a * b;

3:  0 0 0 0 0 0 1 1  *  8
————————————————————
24:  0 0 0 1 1 0 0 0
```

通过以上运算可以看出当用a乘b，且如果b满足2^N的时候 就相当于把a的二进制数据向左移动N位，放到代码中 我们可以这样来写 **a << N**,所以上面**3 \* 2、3 \* 4、3 \* 8**其实是可以写成**3<<1、3<<2、3<<3**，运算结果都是一样的。

那假如相乘的两个数都不满足2^N怎么办呢？其实这个时候编译器会将其中一个数拆分成多个满足2N的数相加的情况，打个比方

```java
int a = 15;             int a = 15
int b = 13;      =>     int b = (4 + 8 + 1)
int c = a * b;          int c = a * b  
```

最后其实执行相乘运算就会变成这样 **15 \* 4 + 15 \* 8 + 15 \* 1**，按照上文说的移位来转换为位运算就会变成**15 << 2 + 15 << 3 + 15 << 0**

# 减法和除法

减法也是与加法同理只不过计算机内减法操作就是加上一个数的负数形式，且在操作系统中都是以补码的形式进行操作(因为正数的原码补码反码都与本身相同)。

除法的话其实和乘法原理相同，不过乘法是左移而除法是右移，但是除法的计算量要比乘法大得多，其大部分的消耗都在拆分数值，和处理小数的步骤上，所以如果我们在进行生成变量的时候如果遇到多位的小数我们尽量把他换成string的形式，这也是为什么浮点运算会消耗大量的时钟周期(操作系统中每进行一个移位或者加法运算的过程所消耗的时间就是一个时钟周期，3.0GHz频率的CPU可以在一秒执行运算3.0*1024*1024*1024个时钟周期)

